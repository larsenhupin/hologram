<html>
	<head>
		<title>viewport and renderer</title>
		<style>
		body {
			margin: 0px;
		}
		
		
		</style>
	</head>
	<body>
	
		
		<canvas id="RendererCanvas"></canvas>
		
		<script src="../libs/three.min.js"></script>
		<script src="../libs/screenfull.js"></script>
		
		<script>
		
		var height = window.innerHeight;
		var width = height;
		
		//console.log(height);
		
		document.body.style.background = "#000000";
		//document.body.style.border-style = "none";
		
		var canvas = document.getElementById("RendererCanvas");
		canvas.width = height;
		canvas.height = height;
		canvas.tabindex = 0;
		canvas.setAttribute('style', "  position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);");
		document.body.appendChild(canvas);
				
		var renderer;
		var camera;
		var scene;
		var loader;
		var model;
		
		var loadingManager;
		var RESOURCES_LOADED;
		var fullscreen;
		var turn_left;
		var turn_right;
		
		init();
		render();
		
		function init(){
			
			console.log(height);
			
			/*document.body.addEventListener('click', () => {
				if (screenfull.enabled) {
				screenfull.request();
				height = window.innerHeight;
				canvas.height = height;
				canvas.width  = height;
				
				console.log(height);
			} else {
		// Ignore or do something else
			}
});			*/
			
			scene = new THREE.Scene();
			//scene.background = new THREE.Color(0xffffff);
			
			/*
			camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
			camera.position.z = -5;
			camera.position.y = 0;
			camera.position.x = 0;
			camera.lookAt(scene.position);
			*/
			
			//Viewport cameras
			frontCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);           			
			scene.add(frontCamera);	
			frontCamera.position.set(0, 0, 5);
			
			
			backCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);           			
			scene.add(backCamera);
			backCamera.position.set(0, 0, -5);
			backCamera.rotation.y = 1 * Math.PI;
			backCamera.rotation.z = 1 * Math.PI;
			backCamera.aspect = window.innerHeight / window.innerHeight;
            backCamera.updateProjectionMatrix();
			
			
			leftCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);           			
			scene.add(leftCamera);
			leftCamera.position.set(-5, 0, 0);
			leftCamera.rotation.y = -0.5 * Math.PI;
			leftCamera.rotation.z = -0.5 * Math.PI;
			leftCamera.aspect = window.innerHeight / window.innerHeight;
            leftCamera.updateProjectionMatrix();
			
			
			rightCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);           			
			scene.add(rightCamera);
			rightCamera.position.set(5, 0, 0);
			rightCamera.rotation.y = 0.5 * Math.PI;
			rightCamera.rotation.z = 0.5 * Math.PI;
			rightCamera.aspect = window.innerHeight / window.innerHeight;
            rightCamera.updateProjectionMatrix();
			
			//Renderer3
			renderer = new THREE.WebGLRenderer({
				canvas: document.getElementById("RendererCanvas"),
				antialias: true
			});
			renderer.setClearColor( 0x000000, 1 );
			renderer.setSize( width, height);
			renderer.autoClear = false;
			
			document.body.appendChild( renderer.domElement );
			
			//Visuals
			
			var light = new THREE.SpotLight();
			light.position.set(5,10,-5);
			scene.add(light);
			
			var geometry = new THREE.BoxGeometry( 5, 5, 5 );
			var material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
			var cube = new THREE.Mesh( geometry, material );
			//scene.add( cube );
			
			loadingManager = new THREE.LoadingManager();
			loadingManager.onLoad = function() {
			RESOURCES_LOADED = true;
            };
			
			loader = new THREE.JSONLoader(loadingManager);
			loader.load(
				'../assets/goldorak.json',
				function (geometry, material){
					var material = new THREE.MeshNormalMaterial();
					model = new THREE.Mesh(geometry, material);
					model.scale.set(1.75, 1.75, 1.75);
					model.position.set(0, -3, 0);
					scene.add(model);
					
				});
				
			

		}	
		
		var onKeyDown = function ( event ) {

			switch ( event.keyCode ) {
			
				case 37:
                turn_left = true;
				console.log(height);
                break;
				
				case 39:
				turn_right = true;
				break;
				
				case 70:
				screenfull.request();
				
				break;
				
			}
		};
		
		var onKeyUp = function ( event ) {

			switch ( event.keyCode ) {
			
				case 37:
                turn_left = false;
                break;
				
				case 39:
				turn_right = false;
				break;
				
				case 70:
				height = window.innerHeight;
				canvas.height = height;
				canvas.width  = height;
				renderer.setSize(height, height);
				console.log(height);
				break;
			}
		};
		

		window.addEventListener( 'resize', onWindowResize, false );
		document.addEventListener('keydown', onKeyDown, false);
		document.addEventListener('keyup', onKeyUp, false);
		
		function onWindowResize(){
			renderer.setSize(height, height);
		
			frontCamera.aspect = window.innerHeight / window.innerHeight;
            frontCamera.updateProjectionMatrix();
			
			height = window.innerHeight;
			width  = window.innerHeight;
			canvas.width = height;
			canvas.height = height;
		}


		function render() {
			requestAnimationFrame( render );
			renderer.setViewport( 0, 0, width, width );
			renderer.clear();
			
			if (RESOURCES_LOADED){
				if(turn_left){
					model.rotation.y += .02;
				}
				if(turn_right){
					model.rotation.y -= .02;
				}
                
                //model.rotation.x += 0.02;
				 model.rotation.y += 0.0125;
				//model.rotation.z += 0.0175;

			}
			
			var point33 = 1/3;
			var deuxTiers = 2/3;
			
			
			/*function onWindowResize() {
            cameraFront.aspect = window.innerWidth / window.innerHeight;
            cameraFront.updateProjectionMatrix();
			
			//camera.aspect = window.innerWidth / window.innerHeight;
            //camera.updateProjectionMatrix();

            renderer.setSize(window.innerHeight, window.innerHeight);
			*/
			
			
			//front view
			
			renderer.setViewport( point33 * height + 1, deuxTiers * height + 1, point33 * height - 2, point33 * height - 2 );
			renderer.render( scene, frontCamera );
			
			//back view
			renderer.setViewport( point33 * height + 1, 1, point33 * height - 2, point33 * height - 2 );
			renderer.render( scene, backCamera );
			
			//left view
			renderer.setViewport( 1, point33 * height + 1,   point33 * height -2 , point33 * height -2);
			renderer.render( scene, leftCamera );
				
			//right view
			renderer.setViewport( deuxTiers * height + 1, point33 * height + 1, point33 * height - 2, point33 * height - 2 );
			renderer.render( scene, rightCamera );
			
		}
			
		</script>
	</body>
</html>